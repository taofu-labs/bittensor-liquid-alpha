# AlphaYieldPool Protocol Contracts

## ❗ Caution ❗

**This code is experimental, has not been professionally audited, and has not undergone comprehensive testing. It should NOT be used in a production environment or with real funds. Use at your own risk.**

## Open Questions & Future Considerations

*   **Resilience to Bittensor Upgrades**:
    *   How can the contract be made more resilient against future upgrades or changes to the Bittensor network, particularly to the precompiled contract addresses or their interfaces?
    *   What are the pros and cons of using a proxy contract pattern (e.g., UUPS or Transparent Upgradeable Proxy) for `AlphaYieldPool.sol` to allow for future logic upgrades without requiring users to migrate their tokens?

---

This directory contains the Solidity smart contracts for the AlphaYieldPool protocol. The core contract is `AlphaYieldPool.sol`, which defines an ERC-20 token representing a share in a pooled Alpha position on the Bittensor network.

## AlphaYieldPool Contract (`AlphaYieldPool.sol`)

### Overview

The `AlphaYieldPool` contract is an ERC-20 token that allows users to participate in TAO staking on the Bittensor network in a liquid manner. Users can:

1.  **Deposit TAO**: Users send native TAO to the contract. The contract then stakes this TAO into a designated validator on a specified Bittensor subnet. In return, the depositor receives freshly-minted AlphaYieldPool tokens, proportional to their contribution.
2.  **Withdraw as Alpha**: Users can burn their AlphaYieldPool tokens to redeem their pro-rata share of the *Alpha* principal **plus any accrued Alpha rewards**.
3.  **Withdraw as TAO**: Users can burn their AlphaYieldPool tokens to redeem their pro-rata share
    of the *Alpha* principal **plus any accrued Alpha rewards** as TAO. The contract first
    unstakes the needed amount then forwards the proceeds in native TAO.

The AlphaYieldPool token itself is an `ERC20` token, also inheriting `ERC20Permit` for gas-less approvals, `Ownable` for administrative controls, and `ReentrancyGuard` for protection against re-entrancy attacks.

### Core Functionality

All core user-facing functions (`depositTao(WithLimit)`, `withdrawAsAlpha`, `withdrawAsTao(WithLimit)`) are protected by the `nonReentrant` modifier.

*   **`depositTao(WithLimit)(address to)`**:
    *   Accepts native TAO ( `msg.value`).
    *   Requires the deposit amount to be above `minDeposit`.
    *   Stakes the received TAO to a validator identified by `validatorUid` on `netuid` by calling `addStake` on the `IStaking` interface. The contract's own address, converted to an SS58 public key (`contractSS58Pub`), is used as the coldkey for staking.
    *   Mints new AlphaYieldPool tokens to the specified `to` address, proportional to the amount of Alpha (staked TAO) generated by the deposit. A `DECIMAL_SCALE_FACTOR` (10^9) is used to manage precision differences between TAO (Rao) and Alpha.
*   **`withdrawAsAlpha(uint256 amount, bytes32 to)`**:
    *   Allows users to burn a specified `amount` of their AlphaYieldPool tokens.
    *   Calculates the pro-rata share of the contract's total Alpha holdings (including rewards).
    *   Transfers this share of Alpha from the contract's stake (associated with the validator's `hotkey` on `netuid`) to the user's specified `to` SS58 address using `transferStake` on the `IStaking` interface.
*   **`withdrawAsTao(WithLimit)(uint256 amount, bytes32 to)`**:
    *   Allows users to burn a specified `amount` of their AlphaYieldPool tokens.
    *   Calculates the pro-rata share of Alpha to be redeemed (including rewards).
    *   Unstakes this amount of Alpha from the validator's `hotkey` on `netuid` using `removeStake` on the `IStaking` interface. The unstaked TAO is sent to the contract's address.
    *   Transfers the received native TAO to the user's specified `to` SS58 address using the `ISubtensorBalanceTransfer` precompile.

### Interfaces and Dependencies

The `AlphaYieldPool` contract interacts with several key components of the Bittensor network via precompiled contracts and interfaces:

*   **[`IStaking`](contracts/StakingInterface.sol:6)** (`0x...805`): Used for staking TAO (`addStake`), unstaking TAO (`removeStake`), transferring staked Alpha (`transferStake`), and moving stake between hotkeys (`moveStake`).
*   **[`IMetagraph`](contracts/MetagraphInterface.sol:15)** (`0x...802`): Used to look up the `hotkey` of the target validator (`validatorUid` on `netuid`).
*   **[`ISubtensorBalanceTransfer`](contracts/BalanceTransfer.sol:6)** (`0x...800`): A precompiled contract used to transfer native TAO to an SS58 address.
*   **[`BLAKE2b`](contracts/BLAKE2b.sol:34)**: A custom implementation of the BLAKE2b hashing algorithm, used internally by `addressToSS58Pub` to convert the contract's EVM address to an SS58 public key format required for staking operations.
*   **OpenZeppelin Contracts**:
    *   `ERC20.sol`: Standard ERC-20 token implementation.
    *   `ERC20Permit.sol`: Implements EIP-2612 for gas-less approvals.
    *   `ReentrancyGuard.sol`: Provides protection against re-entrancy attacks.

## Design Decisions

1.  **ERC-20 Representation for Liquid Staking**:
    *   The core design is to represent a user's share of a pooled TAO stake as a standard,
        liquid ERC-20 token (`AlphaYieldPool`). This allows for easy transfer, use in DeFi
        protocols, and general composability within the Bittensor EVM ecosystem.

3.  **Contract as Staker (Coldkey Derivation)**:
    *   The `AlphaYieldPool` contract itself acts as the coldkey for the pooled stake.
    *   The function `addressToSS58Pub(address addr)` is used to converts the contract's EVM address (or any EVM address) into an SS58 public key format. This involves:
        *   Prefixing the address with `evm:`.
        *   Hashing the result using `blake2b_256`.
    *   This derived SS58 public key (`contractSS58Pub`) is then used in staking operations with the `IStaking` interface.

3.  **Pro-Rata Share Calculation**:
    *   Withdrawals (both as Alpha and as TAO) are based on the user's pro-rata share of the total AlphaYieldPool supply relative to the contract's total Alpha holdings (which includes accrued rewards).
    *   `alphaOut = (current_alpha * amount_burned) / totalSupply()`

4.  **Explicit Hotkey Lookup**:
    *   The contract doesn't assume a fixed hotkey. Instead, it uses `metagraph.getHotkey(netuid, validatorUid)` (via the internal `_validatorHotkey()` helper) to dynamically fetch the hotkey of the target validator. This allows flexibility if the validator changes its hotkey.

5.  **Withdrawal Options**:
    *   Providing two distinct withdrawal methods (`withdrawAsAlpha` and `withdrawAsTao`) gives users flexibility:
        *   `withdrawAsAlpha`: For users who want to receive their staked position directly on
            a specified coldkey without unstaking the alpha. This includes their share of accrued
            Alpha rewards.
        *   `withdrawAsTao(WithLimit)`: For users who want to exit their staked position and receive TAO. This includes their share of accrued Alpha rewards.

7. **Fallback and Receive Functions**:
    *   The `receive() external payable` and `fallback() external payable` functions are implemented to explicitly `revert`. This prevents accidental direct TAO transfers to the contract, enforcing that all deposits must go through the `depositTao` function to ensure proper share accounting and minting of AlphaYieldPool tokens.

## Subnet Deregistration Handling
When the target subnet (netuid) is deregistered, the pool must liquidate all staked Alpha back
into native TAO and hold it in the contract. At that point, AlphaYieldPool tokens can no longer
be redeemed as Alpha; instead, holders burn their pool tokens to withdraw their pro-rata share
of the accumulated TAO via `withdrawTaoAfterDeregistration`. This mechanism guarantees that, upon subnet deregistration, all pool participants can exit fully in TAO, receiving exactly their pro-rata share of the liquidated assets.
The total share is calculated as:

**TAO Share Calculation**

Given:
- `taoBalance`: total TAO held by the contract  
- `shares`: number of pool tokens being burned  
- `totalSupply()`: current total supply of pool tokens  

```math
\text{taoShare} = \frac{\text{taoBalance} \times \text{shares}}{\text{totalSupply()}}
```

## Helper Contracts

*   **[`BLAKE2b.sol`](contracts/BLAKE2b.sol:1)**: Provides an implementation of the BLAKE2b hash function. This is a dependency for converting EVM addresses to SS58 format.
*   **[`BalanceTransfer.sol`](contracts/BalanceTransfer.sol:1)**: Defines the `ISubtensorBalanceTransfer` interface for the precompiled contract responsible for native TAO transfers.
*   **[`MetagraphInterface.sol`](contracts/MetagraphInterface.sol:1)**: Defines the `IMetagraph` interface for interacting with the Bittensor metagraph precompile.
*   **[`StakingInterface.sol`](contracts/StakingInterface.sol:1)**: Defines the `IStaking` interface for interacting with the Bittensor staking precompile.