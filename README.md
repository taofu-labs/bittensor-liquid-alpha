# LiquidAlpha Protocol Contracts

## ❗ Caution ❗

**This code is experimental, has not been professionally audited, and has not undergone comprehensive testing. It should NOT be used in a production environment or with real funds. Use at your own risk.**

## Open Questions & Future Considerations

*   **Decentralizing Admin Controls**: 
    * How can the ownership requirement for setting `validatorUid` and `minDeposit` be removed or decentralized? Could a DAO, multi-sig, or a
    time-locked governance mechanism be implemented?
*   **Default ValidatorUid selection**: 
    * Should the owners uid (0 for netuid >= 65, subnet specific otherwise) be used as the
      default ValidatorUid?
*   **Resilience to Bittensor Upgrades**:
    *   How can the contract be made more resilient against future upgrades or changes to the Bittensor network, particularly to the precompiled contract addresses or their interfaces?
    *   What are the pros and cons of using a proxy contract pattern (e.g., UUPS or Transparent Upgradeable Proxy) for `LiquidAlpha.sol` to allow for future logic upgrades without requiring users to migrate their tokens?
*   **Subnet Deregistration**: How should the contract handle scenarios where the `netuid` it is staked to becomes deregistered? Is there a mechanism to detect this and allow for graceful migration of stake or funds?

---

This directory contains the Solidity smart contracts for the LiquidAlpha protocol. The core contract is `LiquidAlpha.sol`, which defines an ERC-20 token representing a share in a pooled Alpha position on the Bittensor network.

## LiquidAlpha Contract (`LiquidAlpha.sol`)

### Overview

The `LiquidAlpha` contract is an ERC-20 token that allows users to participate in TAO staking on the Bittensor network in a liquid manner. Users can:

1.  **Deposit TAO**: Users send native TAO to the contract. The contract then stakes this TAO into a designated validator on a specified Bittensor subnet. In return, the depositor receives freshly-minted LiquidAlpha tokens, proportional to their contribution.
2.  **Withdraw as Alpha**: Users can burn their LiquidAlpha tokens to redeem their pro-rata share of the *Alpha* principal **plus any accrued Alpha rewards**.
3.  **Withdraw as TAO**: Users can burn their LiquidAlpha tokens to redeem their pro-rata share
    of the *Alpha* principal **plus any accrued Alpha rewards** as TAO. The contract first
    unstakes the needed amount then forwards the proceeds in native TAO.

The LiquidAlpha token itself is an `ERC20` token, also inheriting `ERC20Permit` for gas-less approvals, `Ownable` for administrative controls, and `ReentrancyGuard` for protection against re-entrancy attacks.

### Core Functionality

All core user-facing functions (`depositTao`, `withdrawAsAlpha`, `withdrawAsTao`) are protected by the `nonReentrant` modifier.

*   **`depositTao(address to)`**:
    *   Accepts native TAO ( `msg.value`).
    *   Requires the deposit amount to be above `minDeposit`.
    *   Stakes the received TAO to a validator identified by `validatorUid` on `netuid` by calling `addStake` on the `IStaking` interface. The contract's own address, converted to an SS58 public key (`contractSS58Pub`), is used as the coldkey for staking.
    *   Mints new LiquidAlpha tokens to the specified `to` address, proportional to the amount of Alpha (staked TAO) generated by the deposit. A `DECIMAL_SCALE_FACTOR` (10^9) is used to manage precision differences between TAO (Rao) and Alpha.
*   **`withdrawAsAlpha(uint256 amount, bytes32 to)`**:
    *   Allows users to burn a specified `amount` of their LiquidAlpha tokens.
    *   Calculates the pro-rata share of the contract's total Alpha holdings (including rewards).
    *   Transfers this share of Alpha from the contract's stake (associated with the validator's `hotkey` on `netuid`) to the user's specified `to` SS58 address using `transferStake` on the `IStaking` interface.
*   **`withdrawAsTao(uint256 amount, bytes32 to)`**:
    *   Allows users to burn a specified `amount` of their LiquidAlpha tokens.
    *   Calculates the pro-rata share of Alpha to be redeemed (including rewards).
    *   Unstakes this amount of Alpha from the validator's `hotkey` on `netuid` using `removeStake` on the `IStaking` interface. The unstaked TAO is sent to the contract's address.
    *   Transfers the received native TAO to the user's specified `to` SS58 address using the `ISubtensorBalanceTransfer` precompile.

### Administrative Functions

*   **`setMinDeposit(uint256 _minDeposit)`**: Allows the contract owner to update the minimum TAO deposit amount.
*   **`setStakeTarget(uint16 new_uid)`**: Allows the contract owner to update the `validatorUid` (the UID of the validator to stake to) and moves the entire contract's stake to this new validator by calling `moveStake` on the `IStaking` interface.

### Interfaces and Dependencies

The `LiquidAlpha` contract interacts with several key components of the Bittensor network via precompiled contracts and interfaces:

*   **[`IStaking`](contracts/StakingInterface.sol:6)** (`0x...805`): Used for staking TAO (`addStake`), unstaking TAO (`removeStake`), transferring staked Alpha (`transferStake`), and moving stake between hotkeys (`moveStake`).
*   **[`IMetagraph`](contracts/MetagraphInterface.sol:15)** (`0x...802`): Used to look up the `hotkey` of the target validator (`validatorUid` on `netuid`).
*   **[`ISubtensorBalanceTransfer`](contracts/BalanceTransfer.sol:6)** (`0x...800`): A precompiled contract used to transfer native TAO to an SS58 address.
*   **[`BLAKE2b`](contracts/BLAKE2b.sol:34)**: A custom implementation of the BLAKE2b hashing algorithm, used internally by `addressToSS58Pub` to convert the contract's EVM address to an SS58 public key format required for staking operations.
*   **OpenZeppelin Contracts**:
    *   `ERC20.sol`: Standard ERC-20 token implementation.
    *   `ERC20Permit.sol`: Implements EIP-2612 for gas-less approvals.
    *   `Ownable.sol`: Provides basic access control.
    *   `ReentrancyGuard.sol`: Provides protection against re-entrancy attacks.

## Design Decisions

1.  **ERC-20 Representation for Liquid Staking**:
    *   The core design is to represent a user's share of a pooled TAO stake as a standard, liquid ERC-20 token (`LiquidAlpha`). This allows for easy transfer, use in DeFi protocols, and general composability within the EVM ecosystem.

3.  **Contract as Staker (Coldkey Derivation)**:
    *   The `LiquidAlpha` contract itself acts as the coldkey for the pooled stake.
    *   The function `addressToSS58Pub(address addr)` is used to converts the contract's EVM address (or any EVM address) into an SS58 public key format. This involves:
        *   Prefixing the address with `evm:`.
        *   Hashing the result using `blake2b_256`.
    *   This derived SS58 public key (`contractSS58Pub`) is then used in staking operations with the `IStaking` interface.

3.  **Pro-Rata Share Calculation**:
    *   Withdrawals (both as Alpha and as TAO) are based on the user's pro-rata share of the total LiquidAlpha supply relative to the contract's total Alpha holdings (which includes accrued rewards).
    *   `alphaOut = (current_alpha * amount_burned) / totalSupply()`


4.  **Ownable for Admin Control**:
    *   The contract owner (deployer by default) has administrative privileges to:
        *   Set the `minDeposit` threshold.
        *   Set the `validatorUid` to change the target validator (this action also moves the stake).
    *   This provides a mechanism for managing key parameters of the staking pool post-deployment.

5.  **Explicit Hotkey Lookup**:
    *   The contract doesn't assume a fixed hotkey. Instead, it uses `metagraph.getHotkey(netuid, validatorUid)` (via the internal `_validatorHotkey()` helper) to dynamically fetch the hotkey of the target validator. This allows flexibility if the validator changes its hotkey.

6.  **Withdrawal Options**:
    *   Providing two distinct withdrawal methods (`withdrawAsAlpha` and `withdrawAsTao`) gives users flexibility:
        *   `withdrawAsAlpha`: For users who want to receive their staked position directly on
            a specified coldkey without unstaking the alpha. This includes their share of accrued
            Alpha rewards.
        *   `withdrawAsTao`: For users who want to exit their staked position and receive TAO. This includes their share of accrued Alpha rewards.

7. **Fallback and Receive Functions**:
    *   The `receive() external payable` and `fallback() external payable` functions are implemented to explicitly `revert`. This prevents accidental direct TAO transfers to the contract, enforcing that all deposits must go through the `depositTao` function to ensure proper share accounting and minting of LiquidAlpha tokens.

## Helper Contracts

*   **[`BLAKE2b.sol`](contracts/BLAKE2b.sol:1)**: Provides an implementation of the BLAKE2b hash function. This is a dependency for converting EVM addresses to SS58 format.
*   **[`BalanceTransfer.sol`](contracts/BalanceTransfer.sol:1)**: Defines the `ISubtensorBalanceTransfer` interface for the precompiled contract responsible for native TAO transfers.
*   **[`MetagraphInterface.sol`](contracts/MetagraphInterface.sol:1)**: Defines the `IMetagraph` interface for interacting with the Bittensor metagraph precompile.
*   **[`StakingInterface.sol`](contracts/StakingInterface.sol:1)**: Defines the `IStaking` interface for interacting with the Bittensor staking precompile.